// Code generated by slack-modal-codegen. DO NOT EDIT.

package {{.PackageName}}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"
	"strings"

	"github.com/slack-go/slack"
)

// --- View Submission Handlers ---

{{range .Structs}}
// {{.TypeName}}Handler defines the handler for the "{{.CallbackID}}" view submission.
// Developers should implement this for each modal.
type {{camel .CallbackID}}Handler interface {
    Handle{{camel .CallbackID}}(ctx context.Context, interaction slack.InteractionCallback, input {{.TypeName}}) error
}
{{end}}

// --- Block Action Handlers ---

// BlockActionHandlers defines an interface for all simple block actions that do not require view state.
// A single struct should implement all of these methods.
type BlockActionHandlers interface {
{{- range .SimpleActionIDs}}
    Handle{{. | camel}}(ctx context.Context, interaction slack.InteractionCallback, action slack.BlockAction) error
{{- end}}
}


{{range .Structs}}
// {{.TypeName}}BlockActionHandler defines a handler for a block action that occurs within the
// "{{.CallbackID}}" view. It automatically receives the parsed state of all input blocks in that view.
type {{camel .CallbackID}}BlockActionHandler interface {
    Handle{{camel .CallbackID}}BlockAction(ctx context.Context, interaction slack.InteractionCallback, action slack.BlockAction, input {{.TypeName}}) error
}
{{end}}

// Dispatcher handles the routing of all interaction payloads.
type Dispatcher struct {
    signingSecret       string
	viewHandlers        map[string]interface{}
	blockActionHandlers     BlockActionHandlers // A single handler for all simple block actions.
	viewBlockActionHandlers map[string]interface{} // map[actionID]handler
}

// NewDispatcher creates a new dispatcher.
func NewDispatcher(signingSecret string) *Dispatcher {
	return &Dispatcher{
	    signingSecret      : signingSecret,
		viewHandlers       : make(map[string]interface{}),
		viewBlockActionHandlers: make(map[string]interface{}),
	}
}

// --- Registration Methods ---

{{range .Structs}}
// Register{{.TypeName}}Handler registers a handler for the "{{.CallbackID}}" view submission.
func (d *Dispatcher) Register{{.TypeName}}Handler(handler {{camel .CallbackID}}Handler) {
    d.viewHandlers["{{.CallbackID}}"] = handler
}
{{end}}

{{range .Structs}}
// Register{{.TypeName}}BlockActionHandler registers a handler for a block action by its action ID
// that occurs within the "{{.CallbackID}}" view.
func (d *Dispatcher) Register{{.TypeName}}BlockActionHandler(actionID string, handler {{camel .CallbackID}}BlockActionHandler) {
    d.viewBlockActionHandlers[actionID] = handler
}
{{end}}

// RegisterBlockActionHandlers registers a handler that implements the BlockActionHandlers interface.
func (d *Dispatcher) RegisterBlockActionHandlers(handler BlockActionHandlers) {
	d.blockActionHandlers = handler
}

// HandleInteraction is the core logic that parses the request and calls the dispatcher.
func (d *Dispatcher) HandleInteraction(w http.ResponseWriter, r *http.Request) {
    if err := d.verifySigningSecret(r); err != nil {
        log.Printf("[ERROR] Verify request failed: %v", err)
        w.WriteHeader(http.StatusBadRequest)
		return
    }

    // The payload is URL-encoded, so we must parse it.
	var interaction slack.InteractionCallback
	if err := json.Unmarshal([]byte(r.FormValue("payload")), &interaction); err != nil {
		log.Printf("[ERROR] Failed to unmarshal interaction payload: %v", err)
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Dispatch the interaction to the appropriate handler.
	if err := d.Dispatch(r.Context(), interaction); err != nil {
	    log.Printf("[ERROR] Dispatcher failed: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

    // Respond with a 200 OK to acknowledge receipt of the interaction.
	w.WriteHeader(http.StatusOK)
}

// verifySigningSecret is a function that verifies the request signature.
func (d *Dispatcher) verifySigningSecret(r *http.Request) error {
	// Read the request body.
	body, err := io.ReadAll(r.Body)
	if err != nil {
		return fmt.Errorf("[ERROR] Failed to read request body: %v", err)
	}
	// We have to "replace" the body so it can be read again downstream.
	r.Body = io.NopCloser(bytes.NewBuffer(body))

	// Perform the verification.
	sv, err := slack.NewSecretsVerifier(r.Header, d.signingSecret)
	if err != nil {
		return fmt.Errorf("[ERROR] Failed to create SecretsVerifier: %v", err)
	}

	if _, err := sv.Write(body); err != nil {
		return fmt.Errorf("[ERROR] Failed to write body to verifier: %v", err)
	}

	if err := sv.Ensure(); err != nil {
		return fmt.Errorf("[UNAUTHORIZED] Invalid signing secret: %v", err)
	}

	return nil
}

// Dispatch routes the incoming interaction to the appropriate registered handler.
func (d *Dispatcher) Dispatch(ctx context.Context, interaction slack.InteractionCallback) error {
	switch interaction.Type {
	case slack.InteractionTypeViewSubmission:
		return d.dispatchViewSubmission(ctx, interaction)
	case slack.InteractionTypeBlockActions:
		return d.dispatchBlockActions(ctx, interaction)
	default:
		return fmt.Errorf("unsupported interaction type %s", interaction.Type)
	}
}

// dispatchViewSubmission handles routing for view submissions.
func (d *Dispatcher) dispatchViewSubmission(ctx context.Context, interaction slack.InteractionCallback) error {
	callbackID := interaction.View.CallbackID
	handler, ok := d.viewHandlers[callbackID]
	if !ok {
		return fmt.Errorf("no view handler registered for callback_id: %s", callbackID)
	}

	switch callbackID {
	{{- range .Structs}}
	case "{{.CallbackID}}":
		typedHandler, ok := handler.({{camel .CallbackID}}Handler)
		if !ok {
			return fmt.Errorf("handler for {{.CallbackID}} has incorrect type")
		}
		var input {{.TypeName}}
		if err := unmarshalStateValues(interaction.View.State.Values, &input); err != nil {
			return fmt.Errorf("failed to bind values for '{{.CallbackID}}': %w", err)
		}
		return typedHandler.Handle{{camel .CallbackID}}(ctx, interaction, input)
	{{- end}}
	default:
		return fmt.Errorf("internal dispatcher error: callback_id %s not found in switch", callbackID)
	}
}

// dispatchBlockActions handles routing for block actions.
func (d *Dispatcher) dispatchBlockActions(ctx context.Context, interaction slack.InteractionCallback) error {
	if interaction.ActionCallback.BlockActions == nil {
		return nil // No actions to process
	}
	for _, action := range interaction.ActionCallback.BlockActions {
		// First, check for view-specific handlers that expect state.
		if handler, ok := d.viewBlockActionHandlers[action.ActionID]; ok {
			if interaction.View.CallbackID != "" {
				var handlerErr error
				switch interaction.View.CallbackID {
				{{- range .Structs}}
				case "{{.CallbackID}}":
					typedHandler, ok := handler.({{camel .CallbackID}}BlockActionHandler)
					if !ok { return fmt.Errorf("handler for action '%s' in view '{{.CallbackID}}' has incorrect type", action.ActionID) }
					var input {{.TypeName}}
					if interaction.View.State != nil {
						if err := unmarshalStateValues(interaction.View.State.Values, &input); err != nil {
							return fmt.Errorf("failed to bind state for action '%s' in '{{.CallbackID}}': %w", action.ActionID, err)
						}
					}
					handlerErr = typedHandler.Handle{{camel .CallbackID}}BlockAction(ctx, interaction, *action, input)
				{{- end}}
				}
				if handlerErr != nil {
					return fmt.Errorf("view block action handler for '%s' failed: %w", action.ActionID, handlerErr)
				}
				continue
			}
		}

		// If no view-specific handler was found, fall back to the comprehensive simple block action handler.
		if d.blockActionHandlers != nil {
			var handlerErr error
			switch action.ActionID {
			{{- range .SimpleActionIDs}}
			case "{{.}}":
				handlerErr = d.blockActionHandlers.Handle{{. | camel}}(ctx, interaction, *action)
			{{- end}}
			}
			if handlerErr != nil {
				return fmt.Errorf("block action handler for '%s' failed: %w", action.ActionID, handlerErr)
			}
		}
	}
	return nil
}

// unmarshalStateValues decodes the nested state values from a modal submission into the target struct.
func unmarshalStateValues(stateValues map[string]map[string]slack.BlockAction, target interface{}) error {
	// Create a flat map to hold the values extracted from the Slack payload.
	// Using interface{} allows us to store values of different types (string, int64, []string).
	values := make(map[string]interface{})

	for _, blockActions := range stateValues {
		for actionID, action := range blockActions {
			switch action.Type {
			// These types have their value in a string format.
			case "plain_text_input":
				values[actionID] = action.Value
			case "datepicker":
				values[actionID] = action.SelectedDate
			case "timepicker":
				values[actionID] = action.SelectedTime

			case "number_input":
				values[actionID], _ = strconv.ParseInt(action.Value, 10, 64)

			// These select types return a single string value.
			case "static_select", "external_select", "radio_buttons":
				values[actionID] = action.SelectedOption.Value
			case "users_select":
				values[actionID] = action.SelectedUser
			case "conversations_select":
				values[actionID] = action.SelectedConversation
			case "channels_select":
				values[actionID] = action.SelectedChannel

			// This type returns a native integer (Unix timestamp).
			case "datetimepicker":
				values[actionID] = action.SelectedDateTime

			// These multi-select types return a slice of strings.
			case "checkboxes", "multi_static_select", "multi_external_select":
				var selectedValues []string
				for _, opt := range action.SelectedOptions {
					selectedValues = append(selectedValues, opt.Value)
				}
				values[actionID] = selectedValues
			case "multi_users_select":
				values[actionID] = action.SelectedUsers
			case "multi_conversations_select":
				values[actionID] = action.SelectedConversations
			case "multi_channels_select":
				values[actionID] = action.SelectedChannels
			}
		}
	}

	// Marshal the intermediate map into JSON bytes.
	jsonBytes, err := json.Marshal(values)
	if err != nil {
		return fmt.Errorf("failed to marshal intermediate values to JSON: %w", err)
	}

	// Unmarshal the JSON bytes into the final, strongly-typed target struct.
	dec := json.NewDecoder(strings.NewReader(string(jsonBytes)))
	dec.DisallowUnknownFields() // Be strict: error if the JSON has keys not in the struct.

	if err := dec.Decode(target); err != nil {
		return fmt.Errorf("failed to decode JSON to target struct: %w", err)
	}

	return nil
}
