// Code generated by slack-modal-codegen. DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/slack-go/slack"
)

// --- View Submission Handlers ---

// FullInputModalInputHandler defines the handler for a specific view submission.
// Developers should implement this for each modal.
type FullInputModalInputHandler interface {
	Handle(ctx context.Context, interaction slack.InteractionCallback, input FullInputModalInput) error
}

// --- Block Action Handlers ---

// BlockActionHandler defines the handler for a block action, like a button click.
type BlockActionHandler interface {
	Handle(ctx context.Context, interaction slack.InteractionCallback, action slack.BlockAction) error
}

// Dispatcher handles the routing of all interaction payloads.
type Dispatcher struct {
	viewHandlers        map[string]interface{}
	blockActionHandlers map[string]BlockActionHandler
}

// NewDispatcher creates a new dispatcher.
func NewDispatcher() *Dispatcher {
	return &Dispatcher{
		viewHandlers:        make(map[string]interface{}),
		blockActionHandlers: make(map[string]BlockActionHandler),
	}
}

// --- Registration Methods ---

// RegisterFullInputModalInputHandler registers a handler for the "full_input_modal" view submission.
func (d *Dispatcher) RegisterFullInputModalInputHandler(handler FullInputModalInputHandler) {
	d.viewHandlers["full_input_modal"] = handler
}

// RegisterBlockActionHandler registers a handler for a specific block action ID.
func (d *Dispatcher) RegisterBlockActionHandler(actionID string, handler BlockActionHandler) {
	d.blockActionHandlers[actionID] = handler
}

// Dispatch routes the incoming interaction to the appropriate registered handler.
func (d *Dispatcher) Dispatch(ctx context.Context, interaction slack.InteractionCallback) error {
	switch interaction.Type {
	case slack.InteractionTypeViewSubmission:
		return d.dispatchViewSubmission(ctx, interaction)
	case slack.InteractionTypeBlockActions:
		return d.dispatchBlockActions(ctx, interaction)
	default:
		// Other interaction types (e.g., message_action) can be added here.
		return nil
	}
}

// dispatchViewSubmission handles routing for view submissions.
func (d *Dispatcher) dispatchViewSubmission(ctx context.Context, interaction slack.InteractionCallback) error {
	callbackID := interaction.View.CallbackID
	handler, ok := d.viewHandlers[callbackID]
	if !ok {
		return fmt.Errorf("no view handler registered for callback_id: %s", callbackID)
	}

	switch callbackID {
	case "full_input_modal":
		typedHandler, ok := handler.(FullInputModalInputHandler)
		if !ok {
			return fmt.Errorf("handler for full_input_modal has incorrect type")
		}
		var input FullInputModalInput
		if err := unmarshalStateValues(interaction.View.State.Values, &input); err != nil {
			return fmt.Errorf("failed to bind values for 'full_input_modal': %w", err)
		}
		return typedHandler.Handle(ctx, interaction, input)
	default:
		return fmt.Errorf("internal dispatcher error: callback_id %s not found in switch", callbackID)
	}
}

// dispatchBlockActions handles routing for block actions.
func (d *Dispatcher) dispatchBlockActions(ctx context.Context, interaction slack.InteractionCallback) error {
	if interaction.ActionCallback.BlockActions == nil {
		return nil // No actions to process
	}
	// A single interaction can have multiple actions, process them all.
	for _, action := range interaction.ActionCallback.BlockActions {
		if handler, ok := d.blockActionHandlers[action.ActionID]; ok {
			if err := handler.Handle(ctx, interaction, *action); err != nil {
				return fmt.Errorf("block action handler for action_id '%s' failed: %w", action.ActionID, err)
			}
		}
		// If no handler is registered for an action, we simply ignore it.
	}
	return nil
}

// unmarshalStateValues is a helper to decode the nested state values from a modal
// submission into a flat struct. It now supports more element types.
func unmarshalStateValues(stateValues map[string]map[string]slack.BlockAction, target interface{}) error {
	values := make(map[string]interface{})

	for _, blockActions := range stateValues {
		for actionID, action := range blockActions {
			switch action.Type {
			case "plain_text_input", "datepicker", "timepicker":
				values[actionID] = action.Value
			case "static_select", "radio_buttons":
				if action.SelectedOption.Value != "" {
					values[actionID] = action.SelectedOption.Value
				}
			case "multi_static_select", "checkboxes":
				var selectedValues []string
				for _, opt := range action.SelectedOptions {
					selectedValues = append(selectedValues, opt.Value)
				}
				// Marshal to a JSON string so it fits in the string field.
				jsonBytes, err := json.Marshal(selectedValues)
				if err != nil {
					return fmt.Errorf("failed to marshal multi-select options for %s: %w", actionID, err)
				}
				values[actionID] = string(jsonBytes)
			case "button":
				// Buttons do not have state values in a view submission, they trigger block actions.
				// We can safely ignore them here.
			default:
				// Potentially log unhandled but present state values.
			}
		}
	}

	jsonBytes, err := json.Marshal(values)
	if err != nil {
		return fmt.Errorf("failed to marshal intermediate values to JSON: %w", err)
	}

	// Use a decoder to handle potential type mismatches more gracefully.
	dec := json.NewDecoder(strings.NewReader(string(jsonBytes)))
	dec.DisallowUnknownFields() // Be strict about matching fields.

	if err := dec.Decode(target); err != nil {
		return fmt.Errorf("failed to decode JSON to target struct: %w", err)
	}

	return nil
}
